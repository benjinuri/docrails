h2. 마이그레이션

마이그레이션은 체계적이고 유기적인 방법으로 데이터베이스를 변경할 수 있는 편리한 방법입니다. 여러분은 손수 SQL을 수정할 수 있습니다. 그러나 수정후에 다른 개발자들에게 수정 사항을 알려줘야할 책임을 가지게 될겁니다. 그리고 다음에 제품을 배포 할때도 변경 사항이 실행되는지 이를 지켜봐야만 합니다.

엑티브 레코드는 이미 실행된 마이그레이션을 추적합니다. 그래서 여러분이 해야할 일은 소스를 업데이트 하고 +rake db:migrate+ 명령을 실행하는 일 뿐입니다. 엑티브 레코드는 실행해야 할 마이그레이션만 작업을 진행합니다. 그리고 여러분의 데이터베이스의 구조에 부합하는 +db/schema.rb+ 파일도 갱신합니다.

마이그레이션은 루비를 이용해서 이러한 변경 사항을 기술합니다. 이것의 굉장한 점은, 대부분의 엑티브 레코드의 기능처럼 데이터베이스에 독립적이라는 것 입니다.: +SELECT *+ 의 다양한 변화에 비한다면야, +CREATE TABLE+의 정확한 문법에 대해서 크게 걱정할 필요가 없습니다. (데이터베이스의 특별한 기능들을 위해 기존 SQL도 사용할 수 있습니다.) 예를 들어, 개발에서는 SQLite3 를 사용하지만, 제품에서는 MySQL을 사용할 수 있죠. 

여러분은 다음 내용의 마이그레이션 관한 모든걸 배울 수 있습니다.:

* 제너레이터(generators) 사용하고 만들기
* 엑티브 레코드가 제공하는 데이터베이스 관리 메소드
* 마이그레이션을 관리하는 Rake 태스크
* 마이그레이션과 +schema.rb+ 의 관계

endprologue.

h3(#Anatomy-of-a-Migration). 마이그레이션 분석

마이그레이션의 자세한 부분을 다루기 앞서, 여러분이 수행할 수 있는 몇 가지 예제가 있습니다.:

<ruby>
class CreateProducts < ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def self.down
    drop_table :products
  end
end
</ruby>

이 마이그레이션은 문자열 컬럼 +name+과 텍스트 컬럼 +description+으로 구성된 +products+ 테이블을 추가합니다. primary 키 컬럼 +id+도 역시 추가됩니다. 그렇지만 이에 관련한 세팅은 기본 설정입니다. 엑티브 레코드가 자동으로 생성하는 타임스탬프 컬럼인 +created_at+ 과 +updated_at+도 추가됩니다. 이 마이그레이션은 간단하게 테이블을 삭제하는 것으로 되돌릴 수 있습니다.

마이그레이션은 스키마의 변경에만 그치는게 아닙니다. 마이그레이션을 데이터베이스내의 잘못된 데이터를 고치거나, 새로운 필드를 만드는데도 사용할 수 있습니다.:

<ruby>
class AddReceiveNewsletterToUsers < ActiveRecord::Migration
  def self.up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default => false
    end
    User.update_all ["receive_newsletter = ?", true]
  end

  def self.down
    remove_column :users, :receive_newsletter
  end
end
</ruby>

이 마이그레이션은 +receive_newsletter+ 컬럼을 +user+ 테이블에 추가합니다. 우리는 새로운 사용자에 대해서는 기본 값을 +false+로 하기를 원하지만, 기존 사용자에 대해서도 옵션을 생각해야 합니다. 그래서 User 모델을 기존 사용자들에 대해 해당 플래그를 +true+로 세팅하는데 사용합니다. 

NOTE: 마이그레이션 중에서 모델을 사용하는데 몇가지 "주의사항":#using-models-in-your-migrations 을 참고하세요.

h4(#migrations-are-classes). 마이그레이션은 클래스이다.

마이그레이션은 +up+(필요한 변경 사항을 수행합니다.)과 +down+(변경 사항을 되돌립니다.)을 구현한 <tt>ActiveRecord::Migration</tt>의 서브 클래스 입니다.

엑티브 레코드는 데이터베이스 독립적인 방법으로 일반적인 데이터 정의 태스크를 수행하는 메소드들을 제공합니다. (여러분은 나중에 이에 관해서 자세히 배울 것입니다.):

* +create_table+
* +change_table+
* +drop_table+
* +add_column+
* +change_column+
* +rename_column+
* +remove_column+
* +add_index+
* +remove_index+

만약, 여러분의 데이터베이스에 특화된 일을 수행할 필요가 있다면 (예컨데 "foreign 키":#active-record-and-referential-integrity 제약사항 만들기), +execute+ 함수로 임의의 SQL을 실행할 수 있습니다. 마이그레이션은 단지 보통 루비 클래스 입니다. 그래서 이런 함수에 대한 제약 사항은 없습니다. 예를 들어, 컬럼을 추가한 후에 이미 존재하는 레코드를 위해서 추가된 컬에 값을 세팅하는 코드를 작성할 수 있습니다. (필요시 여러분의 모델을 사용해야 합니다.)

데이터베이스가 스키마 변경을 위한 트랜젝션을 제공하면(가령 PostgreSQL 혹은 SQLite3), 마이그레이션은 트랜젝셔에 감싸입니다. 만약 이를 지원하지 않으면 (가령 MySQL), 마이그레이션이 실패 했을때 변경이 적용된 부분들이 되돌아가지(roll back) 못할 것입니다. 이 상황에서 변경된 부분을 손수 되돌려야 할 것입니다.

h4(#whats-in-a-name). 이름은 무엇을 의미하는가.

마이그레이션은 각 마이그레이션 클래스당 하나의 파일로 +db/migrate+에 저장됩니다. 파일의 이름은 +YYYYMMDDHHMMSS_create_products.rb+한 형태의 포맷입니다. 이 이름은 UTC 타임스탬프 마이그레이션 식별자와 언더스코어(_ 모양의 글자)로 연결된 마이그레이션의 이름으로 구성됩니다. 마이그레이션 클래스의 이름( CamelCase 버전)은 반드시 파일 이름의 글자 부분과 맞아야합니다. 예를들어서 +20080906120000_create_products.rb+는 반드시 +CreateProducts+을 정의해야 하고, +20080906120001_add_details_to_products.rb+는 반드시 +AddDetailsToProducts+을 정의해야 합니다. 만약 파일의 이름을 변경하려면, 반드시 파일 내부의 클래스의 이름도 <em>변경해야 합니다.</em> 그렇지 않으면, 레일즈는 클래스를 찾지 못해서 에러를 보고 할 것입니다.

레일즈는 내부적으로 오직 마이그레이션의 번호(타임스탬프를 의미)를 마이그레이션 식별에 사용합니다. 레일즈 2.1 이전에 마이그레이션 번호는 1부터 시작해서 마이그레이션이 생성될때 마다 증가하는 값을 취했습니다. 여러명의 개발자들이 함께 개발할때, 이 규칙은 소규모의 충돌 상황에서도 롤백하고 번호를 마이그레이션의 번호를 다시 매기는 상황을 만들었습니다. 레일즈 2.1에서 마이그레이션의 생성 시각을 식별하는데 사용해서 이러한 문제 상황을 대부분 피할 수 있게 했습니다. +config/application.rb+에 다음 라인을 추가시키면 예전 방식의 번호 매기는 방식으로 돌아갈 수 있습니다.

<ruby>
config.active_record.timestamped_migrations = false
</ruby>

타임스탬프와 마이그레이션을 기록하는 조합은 레일즈가 여러 개발자들이 마이그레이션에 관여하면서 생기는 일반적인 상황을 다룰 수 있게 해주었습니다.

예를들어서 앨리스가 마이그레이션 +20080906120000+과 +20080906123000+을 추가하고 밥이 +20080906124500+를 추가시킨 후 이를 실행합니다. 앨리스는 그녀의 마이그레이션에서 변경을 완료하고 점검합니다. 그리고 밥은 자신의 소스에 최근 변경 사항을 내려 받습니다. 레일즈는 앨리스의 두개의 마이그레이션을 아직 실행하지 않았다는걸 알 수있어서, +rake db:migrate+은 이들 마이그레이션을 실행합니다. (더 이후의 타임스템프 값을 가진 밥의 마이그레이션을 실행하는데도 말이죠.) 그리고 이 과정과 비슷하게 마이그레이션 다운(down)시에도 앨리스의 +down+ 메소드를 실행하지 않습니다.

물론, 이는 팀간의 대화를 대체하는건 아닙니다. 예를 들어서, 만약 앨리스의 마이그레이션이 밥의 마이그레이션 실행에 필요한 테이블을 삭제하면, 문제는 확연히 발생합니다.

h4(#changing-migrations). 마이그레이션 변경하기

때로, 마이그리션을 작성할때 여러분은 실수를 하게 됩니다. 이미 마이그레이션을 실행한 후에는, 단순히 마이그레이션을 수정하고 다시 실행하는 것으로 원하는 변경을 반영할 수는 없습니다.:레일즈는 이미 실행된 마이그레이션이라면, +rake db:migrate+를 수행할때 아무 것도 수행하지 않습니다. 여러분은 반드시 마이그레이션을 되돌(rollback)리고 (예를 들어, +rake db:rollback+를 사용), 마이그레이션을 수정하고 정확한 버전에 대하여 +rake db:migrate+를 실행해야 합니다.

일반적으로 마이그레이션 수정은 좋은 생각이 아닙니다.:여러분은 자신과 동료들을 위해서 추가적인 일을 만들어내고, 만약 제품에 이미 적용된 마이그레이션을 수정하면 골치 아픈 상황을 만들어 낼겁니다. 대신에 필요한 변경을 수행하는 새로운 마이그레이션을 만드세요. 소스 관리 도구에 커밋되지 않은(혹은 좀 더 일반적으로 표현하자면 여러분의 개발 머신 이외에 퍼지지 않은) 새로운 마이그레이션을 수정하는 편이 상대적으로 무해합니다. 이런건 그냥 상식이죠.

h3(#creating-a-migration). 마이그레이션 만들기

h4(#creating-a-model). 모델 만들기

모델과 발판(scaffold) 제너레이터는 새로운 모델을 추가를 위한 적합한 마이그레이션을 만들 것입니다. 이 마이그레이션은 이미 관련된 테이블 생성에 대한 코드를 담고 있을 것입니다. 만약 레일즈에게 여러분이 원하는 컬럼들을 알려주면 이 역시 함께 생성됩니다. 예를들어서 다음과 같이 실행하면

<shell>
rails generate model Product name:string description:text
</shell>

다음과 같은 마이그레이션이 생성됩니다.

<ruby>
class CreateProducts < ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def self.down
    drop_table :products
  end
end
</ruby>

여러분이 원하는 컬럼을 얼마든지 name/type 형태로 추가할 수 있습니다. 기본값으로, +t.timestamps+가 추가되어 있습니다.(이 구문으로 생성된 +updated_at+과 +created_at+ 컬럼은 엑티브 레코드에 의해서 자동으로 채워집니다.)

h4(#creating-a-standalone-migration). 독립적인(Standalone) 마이그레이션 만들기

만약 다른 목적으로 (가령, 이미 존재하는 테이블에 컬럼을 추가하는 경우) 마이그레이션을 만들려면, 마이그레이션 제너레이터를 사용할 수 있습니다.

<shell>
rails generate migration AddPartNumberToProducts
</shell>

이 명령은 비어있지만, 정확한 이름을 가진 마이그레이션을 만듭니다.:

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  def self.up
  end

  def self.down
  end
end
</ruby>

만약 마이그레이션 이름이 "AddXXXToYYY" 혹은 "RemoveXXXFromYYY" 이고 이후에 컬럼 이름과 타입을 입력하면 정확한 +add_column+ 과 +remove_column+ 구문이 생성될 것입니다.

<shell>
rails generate migration AddPartNumberToProducts part_number:string
</shell>

이 명령은 다음을 생성하죠.

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  def self.up
    add_column :products, :part_number, :string
  end

  def self.down
    remove_column :products, :part_number
  end
end
</ruby>

비슷하게,

<shell>
rails generate migration RemovePartNumberFromProducts part_number:string
</shell>

다음의 내용을 생성합니다.

<ruby>
class RemovePartNumberFromProducts < ActiveRecord::Migration
  def self.up
    remove_column :products, :part_number
  end

  def self.down
    add_column :products, :part_number, :string
  end
end
</ruby>

마술 같은 컬럼 만들기는 하나만 할 수 있는게 아닙니다. 예를들어서

<shell>
rails generate migration AddDetailsToProducts part_number:string price:decimal
</shell>

명령은 다음을 생성합니다.

<ruby>
class AddDetailsToProducts < ActiveRecord::Migration
  def self.up
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end

  def self.down
    remove_column :products, :price
    remove_column :products, :part_number
  end
end
</ruby>

늘, 시작점이 될만한 것을 만들 수 있습니다. 여기에서 부터 여러분에 입맛에 맞게 추가하고 삭제하면 됩니다.

h3(#writing-a-migration). 마이그레이션 작성하기

Once you have created your migration using one of the generators it's time to get to work!

h4. Creating a Table

Migration method +create_table+ will be one of your workhorses. A typical use would be

<ruby>
create_table :products do |t|
  t.string :name
end
</ruby>

which creates a +products+ table with a column called +name+ (and as discussed below, an implicit +id+ column).

The object yielded to the block allows you to create columns on the table. There are two ways of doing this: The first (traditional) form looks like

<ruby>
create_table :products do |t|
  t.column :name, :string, :null => false
end
</ruby>

the second form, the so called "sexy" migration, drops the somewhat redundant +column+ method. Instead, the +string+, +integer+, etc. methods create a column of that type. Subsequent parameters are the same.

<ruby>
create_table :products do |t|
  t.string :name, :null => false
end
</ruby>

By default +create_table+ will create a primary key called +id+. You can change the name of the primary key with the +:primary_key+ option (don't forget to update the corresponding model) or if you don't want a primary key at all (for example for a HABTM join table) you can pass +:id => false+. If you need to pass database specific options you can place an SQL fragment in the +:options+ option. For example

<ruby>
create_table :products, :options => "ENGINE=BLACKHOLE" do |t|
  t.string :name, :null => false
end
</ruby>

will append +ENGINE=BLACKHOLE+ to the SQL statement used to create the table (when using MySQL the default is +ENGINE=InnoDB+).

The types supported by Active Record are +:primary_key+, +:string+, +:text+, +:integer+, +:float+, +:decimal+, +:datetime+, +:timestamp+, +:time+, +:date+, +:binary+, +:boolean+.

These will be mapped onto an appropriate underlying database type, for example with MySQL +:string+ is mapped to +VARCHAR(255)+. You can create columns of types not supported by Active Record when using the non-sexy syntax, for example

<ruby>
create_table :products do |t|
  t.column :name, 'polygon', :null => false
end
</ruby>

This may however hinder portability to other databases.

h4. Changing Tables

A close cousin of +create_table+ is +change_table+, used for changing existing tables. It is used in a similar fashion to +create_table+ but the object yielded to the block knows more tricks. For example

<ruby>
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
</ruby>
removes the +description+ and +name+ columns, creates a +part_number+ column and adds an index on it. Finally it renames the +upccode+ column.   This is the same as doing

<ruby>
remove_column :products, :description
remove_column :products, :name
add_column :products, :part_number, :string
add_index :products, :part_number
rename_column :products, :upccode, :upc_code
</ruby>

You don't have to keep repeating the table name and it groups all the statements related to modifying one particular table. The individual transformation names are also shorter, for example +remove_column+ becomes just +remove+ and +add_index+ becomes just +index+.

h4. Special Helpers

Active Record provides some shortcuts for common functionality. It is for example very common to add both the +created_at+ and +updated_at+ columns and so there is a method that does exactly that:

<ruby>
create_table :products do |t|
  t.timestamps
end
</ruby>
will create a new products table with those two columns (plus the +id+ column) whereas

<ruby>
change_table :products do |t|
  t.timestamps
end
</ruby>
adds those columns to an existing table.

The other helper is called +references+ (also available as +belongs_to+). In its simplest form it just adds some readability

<ruby>
create_table :products do |t|
  t.references :category
end
</ruby>

will create a +category_id+ column of the appropriate type. Note that you pass the model name, not the column name. Active Record adds the +_id+ for you. If you have polymorphic +belongs_to+ associations then +references+ will add both of the columns required:

<ruby>
create_table :products do |t|
  t.references :attachment, :polymorphic => {:default => 'Photo'}
end
</ruby>
will add an +attachment_id+ column and a string +attachment_type+ column with a default value of 'Photo'.

NOTE: The +references+ helper does not actually create foreign key constraints for you. You will need to use +execute+ for that or a plugin that adds "foreign key support":#active-record-and-referential-integrity.

If the helpers provided by Active Record aren't enough you can use the +execute+ function to execute arbitrary SQL.

For more details and examples of individual methods check the API documentation, in particular the documentation for "<tt>ActiveRecord::ConnectionAdapters::SchemaStatements</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html (which provides the methods available in the +up+ and +down+ methods),  "<tt>ActiveRecord::ConnectionAdapters::TableDefinition</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html (which provides the methods available on the object yielded by +create_table+) and "<tt>ActiveRecord::ConnectionAdapters::Table</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html (which provides the methods available on the object yielded by +change_table+).

h4. Writing Your +down+ Method

The +down+ method of your migration should revert the transformations done by the +up+ method. In other words the database schema should be unchanged if you do an +up+ followed by a +down+. For example if you create a table in the +up+ method you should drop it in the +down+ method. It is wise to do things in precisely the reverse order to in the +up+ method. For example

<ruby>
class ExampleMigration < ActiveRecord::Migration

  def self.up
    create_table :products do |t|
      t.references :category
    end
    #add a foreign key
    execute <<-SQL
      ALTER TABLE products
        ADD CONSTRAINT fk_products_categories
        FOREIGN KEY (category_id)
        REFERENCES categories(id)
    SQL

    add_column :users, :home_page_url, :string

    rename_column :users, :email, :email_address
  end

  def self.down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
    execute "ALTER TABLE products DROP FOREIGN KEY fk_products_categories"
    drop_table :products
  end
end
</ruby>
Sometimes your migration will do something which is just plain irreversible, for example it might destroy some data. In cases like those when you can't reverse the migration you can raise +IrreversibleMigration+ from your +down+ method. If someone tries to revert your migration an error message will be
displayed saying that it can't be done.


h3. Running Migrations

Rails provides a set of rake tasks to work with migrations which boils down to running certain sets of migrations. The very first migration related rake task you use will probably be +db:migrate+. In its most basic form it just runs the +up+ method for all the migrations that have not yet been run. If there are no such migrations it exits.

Note that running the +db:migrate+ also invokes the +db:schema:dump+ task, which will update your db/schema.rb file to match the structure of your database.

If you specify a target version, Active Record will run the required migrations (up or down) until it has reached the specified version. The
version is the numerical prefix on the migration's filename. For example to migrate to version 20080906120000 run

<shell>
rake db:migrate VERSION=20080906120000
</shell>

If this is greater than the current version (i.e. it is migrating upwards) this will run the +up+ method on all migrations up to and including 20080906120000, if migrating downwards this will run the +down+ method on all the migrations down to, but not including, 20080906120000.

h4. Rolling Back

A common task is to rollback the last migration, for example if you made a mistake in it and wish to correct it. Rather than tracking down the version number associated with the previous migration you can run

<shell>
rake db:rollback
</shell>

This will run the +down+ method from the latest migration. If you need to undo several migrations you can provide a +STEP+ parameter:

<shell>
rake db:rollback STEP=3
</shell>

will run the +down+ method from the last 3 migrations.

The +db:migrate:redo+ task is a shortcut for doing a rollback and then migrating back up again. As with the +db:rollback+ task you can use the +STEP+ parameter if you need to go more than one version back, for example

<shell>
rake db:migrate:redo STEP=3
</shell>

Neither of these Rake tasks do anything you could not do with +db:migrate+, they are simply more convenient since you do not need to explicitly specify the version to migrate to.

Lastly, the +db:reset+ task will drop the database, recreate it and load the current schema into it.

NOTE: This is not the same as running all the migrations - see the section on "schema.rb":#schema-dumping-and-you.

h4. Being Specific

If you need to run a specific migration up or down the +db:migrate:up+ and +db:migrate:down+ tasks will do that. Just specify the appropriate version and the corresponding migration will have its +up+ or +down+ method invoked, for example

<shell>
rake db:migrate:up VERSION=20080906120000
</shell>

will run the +up+ method from the 20080906120000 migration. These tasks check whether the migration has already run, so for example +db:migrate:up VERSION=20080906120000+ will do nothing if Active Record believes that 20080906120000 has already been run.

h4. Being Talkative

By default migrations tell you exactly what they're doing and how long it took. A migration creating a table and adding an index might produce output like this

<shell>
20080906170109 CreateProducts: migrating
-- create_table(:products)
   -> 0.0021s
-- add_index(:products, :name)
   -> 0.0026s
20080906170109 CreateProducts: migrated (0.0059s)
</shell>

Several methods are provided that allow you to control all this:

* +suppress_messages+ suppresses any output generated by its block
* +say+ outputs text (the second argument controls whether it is indented or not)
* +say_with_time+ outputs text along with how long it took to run its block. If the block returns an integer it assumes it is the number of rows affected.

For example, this migration

<ruby>
class CreateProducts < ActiveRecord::Migration
  def self.up
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end
    say "Created a table"
    suppress_messages {add_index :products, :name}
    say "and an index!", true
    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end

  def self.down
    drop_table :products
  end
end
</ruby>

generates the following output

<shell>
20080906170109 CreateProducts: migrating
  Created a table
   -> and an index!
  Waiting for a while
   -> 10.0001s
   -> 250 rows
20080906170109 CreateProducts: migrated (10.0097s)
</shell>

If you just want Active Record to shut up then running +rake db:migrate VERBOSE=false+ will suppress any output.

h3(#using-models-in-your-migrations). Using Models in Your Migrations

When creating or updating data in a migration it is often tempting to use one of your models. After all they exist to provide easy access to the underlying data. This can be done but some caution should be observed.

Consider for example a migration that uses the +Product+ model to update a row in the corresponding table. Alice later updates the +Product+ model, adding a new column and a validation on it. Bob comes back from holiday, updates the source and runs outstanding migrations with +rake db:migrate+, including the one that used the +Product+ model. When the migration runs the source is up to date and so the +Product+ model has the validation added by Alice. The database however is still old and so does not have that column and an error ensues because that validation is on a column that does not yet exist.

Frequently I just want to update rows in the database without writing out the SQL by hand: I'm not using anything specific to the model. One pattern for this is to define a copy of the model inside the migration itself, for example:

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  class Product < ActiveRecord::Base
  end

  def self.up
    ...
  end

  def self.down
    ...
  end
end
</ruby>
The migration has its own minimal copy of the +Product+ model and no longer cares about the +Product+ model defined in the application.

h4. Dealing with Changing Models

For performance reasons information about the columns a model has is cached. For example if you add a column to a table and then try and use the corresponding model to insert a new row it may try to use the old column information. You can force Active Record to re-read the column information with the +reset_column_information+ method, for example

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  class Product < ActiveRecord::Base
  end

  def self.up
    add_column :product, :part_number, :string
    Product.reset_column_information
    ...
  end

  def self.down
    ...
  end
end
</ruby>


h3. Schema Dumping and You

h4. What are Schema Files for?

Migrations, mighty as they may be, are not the authoritative source for your database schema. That role falls to either +db/schema.rb+ or an SQL file which Active Record generates by examining the database. They are not designed to be edited, they just represent the current state of the database.

There is no need (and it is error prone) to deploy a new instance of an app by replaying the entire migration history. It is much simpler and faster to just load into the database a description of the current schema.

For example, this is how the test database is created: the current development database is dumped (either to +db/schema.rb+ or +db/development.sql+) and then loaded into the test database.

Schema files are also useful if you want a quick look at what attributes an Active Record object has. This information is not in the model's code and is frequently spread across several migrations but is all summed up in the schema file. The "annotate_models":http://agilewebdevelopment.com/plugins/annotate_models plugin, which automatically adds (and updates) comments at the top of each model summarizing the schema, may also be of interest.

h4. Types of Schema Dumps

There are two ways to dump the schema. This is set in +config/application.rb+ by the +config.active_record.schema_format+ setting, which may be either +:sql+ or +:ruby+.

If +:ruby+ is selected then the schema is stored in +db/schema.rb+. If you look at this file you'll find that it looks an awful lot like one very big migration:

<ruby>
ActiveRecord::Schema.define(:version => 20080906171750) do
  create_table "authors", :force => true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", :force => true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end
</ruby>

In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using +create_table+, +add_index+, and so on. Because this is database independent it could be loaded into any database that Active Record supports. This could be very useful if you were to distribute an application that is able to run against multiple databases.

There is however a trade-off: +db/schema.rb+ cannot express database specific items such as foreign key constraints, triggers or stored procedures. While in a migration you can execute custom SQL statements, the schema dumper cannot reconstitute those statements from the database. If you are using features like this then you should set the schema format to +:sql+.

Instead of using Active Record's schema dumper the database's structure will be dumped using a tool specific to that database (via the +db:structure:dump+ Rake task) into +db/#{Rails.env}_structure.sql+. For example for PostgreSQL the +pg_dump+ utility is used and for MySQL this file will contain the output of +SHOW CREATE TABLE+ for the various tables. Loading this schema is simply a question of executing the SQL statements contained inside.

By definition this will be a perfect copy of the database's structure but this will usually prevent loading the schema into a database other than the one used to create it.

h4. Schema Dumps and Source Control

Because schema dumps are the authoritative source for your database schema, it is strongly recommended that you check them into source control.

h3. Active Record and Referential Integrity

The Active Record way claims that intelligence belongs in your models, not in the database. As such, features such as triggers or foreign key constraints, which push some of that intelligence back into the database, are not heavily used.

Validations such as +validates :foreign_key, :uniqueness => true+ are one way in which models can enforce data integrity. The +:dependent+ option on associations allows models to automatically destroy child objects when the parent is destroyed. Like anything which operates at the application level these cannot guarantee referential integrity and so some people augment them with foreign key constraints.

Although Active Record does not provide any tools for working directly with such features, the +execute+ method can be used to execute arbitrary SQL. There are also a number of plugins such as "foreign_key_migrations":http://github.com/harukizaemon/redhillonrails/tree/master/foreign_key_migrations/ which add foreign key support to Active Record (including support for dumping foreign keys in +db/schema.rb+).

h3. Changelog

* July 15, 2010: minor typos corrected by "Jaime Iniesta":http://jaimeiniesta.com
* September 14, 2008: initial version by "Frederick Cheung":credits.html#fcheung
